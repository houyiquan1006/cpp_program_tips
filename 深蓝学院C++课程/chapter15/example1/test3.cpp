#include <iostream>

/***************************** 枚举与联合 *******************************************************
 * 1. 枚举（enum）: 一种取值受限的特殊类型
 *  - 分为无作用域枚举和有作用域枚举（c++11 起）两种
 *  - 枚举项缺省使用 0 初始化，一次递增，可以使用常亮表达式修改缺省值
 *  - 可以为枚举指定底层类型，表明了枚举项的尺寸
 *  - 无作用域枚举项可隐式转换为整数值；可也用 static_cast 在枚举项与整数值之间转换
 *  - 注意区分枚举的定义与声明
 * 
 * 2. 联合（union）：将多个类型合并到一起以节省空间 
 *  - 通常与枚举一起使用
 *  - 匿名联合
 *  - 在联合中包含非内建类型（c++ 11 起）
 * 
 *********************************************************************************************************/
enum Color    // c++11 之前的无作用域枚举写法
{
    Red,        // 枚举项在缺省的情况下 默认是 0 开始的整数值。
    Green,
    Blue = 100,
};


enum class Color2     // c++11 之后 使用有作用域的枚举类型，即可避免名称污染。
{
    Red  = 100,      // 自定义 枚举类型的某个值
    Green = 1 ,
    Blue = 102 ,
};


union INT    // 将多种类型放在一起，联合体的内存占用的空间大小是其中某个内存占用最大类型的大小
{
    char x;
    int m;
};


int main()
{
    Color x = Red;
    std::cout<< x <<std::endl;    // 打印的将是该枚举对象的次序编号 ID 
    Color z = Blue;
    std::cout<< z <<std::endl;    // 打印的将是该枚举对象的次序编号 ID  100
    
    Color2 y = Color2::Red;     // 此时就必须使用带作用域的符号，否则报错显示找不到该对象。
    // std::cout<< Color2::Red <<std::endl;      // 使用有作用域的枚举，是不能够直接输出对应元素的 ID 的,需要使用 static_cast 来强制转换
    std::cout<< static_cast<int>(Color2::Blue) <<std::endl;
    
    return 0 ;
}