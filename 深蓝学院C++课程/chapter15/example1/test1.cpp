#include <iostream>

/***************************** 异常处理  ******************************************************
 * 1. 用于处理程序在调用过程中的非正常行为
 *  - 传统的处理方法：传返回值表示函数调用是否正常结束
 *  - c++ 中的处理方法：通过关键字 try / catch / throw 引入异常处理机制
 * 
 * 2. 异常触发时的系统行为 ——栈展开
 *  - 抛出异常后续的代码不会被执行
 *  - 局部对象会按照构造相反的顺序销毁
 *  - 系统尝试匹配相应的 catch 代码段
 *      - 如果匹配则执行其中的逻辑，之后执行 catch 后续的代码
 *      - 如果不匹配则继续进行栈展开，直到跳出 main 函数，触发 terminal 结束运行
 * 
 * 3. 异常对象
 *  - 系统会使用抛出的异常拷贝初始化一个临时对象，称为异常对象
 *  - 异常对象会在栈展开过程中被保留，并最终传递给匹配的 catch 语句
 * 
 * 4. try / catch 语句块
 *  - 一个 try 语句块后面可以跟一到多个catch语句块  ***
 *  - 每个 catch 语句块用于匹配一种类型的异常对象
 *  - catch 语句块的匹配按照从上到下进行    **
 *  - 使用 catch(... )  匹配任意异常
 *  - 在 catch 中调用 throw 继续抛出相同的异常
 * 
 * 5. 在一个异常未处理完成时抛出新的异常会导致程序崩溃
 *  - 不要在析构函数或 operator delete 函数重载版本中抛出异常
 *  - 通常来说，catch 所接收的异常类型为引用类型
 * 
 * 
**********************************************************************************************/

void f1()
{
    throw 1;
    std::cout<< "balaba \n";   // throw 抛出异常之后，其后面的东西不会被执行。
}

void f2()
{
    f1();
    throw 2.5;
}

void f3()
{
    f2();
}


int main()
{
    try{
        f3();
    }
    catch(double a)      // 因为第一个抛出的异常是 int 类型的 1 ，所以先匹配的 catch 是 int 型的，最后就结束程序了。
    {
        std::cout<< " exception is occured , value is :"<< a <<std::endl;
        
    }
    catch(int e)      // fun1 中抛出的异常对象 1 将会一直被保留，直到遇到该句语句接收异常后才会消失
    {
        std::cout<< " exception is occured,value is :"<< e << std::endl;
     
    }

    return 0 ;
}
